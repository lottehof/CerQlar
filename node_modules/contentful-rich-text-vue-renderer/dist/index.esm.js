var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var blocks = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.BLOCKS = void 0;
(function (BLOCKS) {
    BLOCKS["DOCUMENT"] = "document";
    BLOCKS["PARAGRAPH"] = "paragraph";
    BLOCKS["HEADING_1"] = "heading-1";
    BLOCKS["HEADING_2"] = "heading-2";
    BLOCKS["HEADING_3"] = "heading-3";
    BLOCKS["HEADING_4"] = "heading-4";
    BLOCKS["HEADING_5"] = "heading-5";
    BLOCKS["HEADING_6"] = "heading-6";
    BLOCKS["OL_LIST"] = "ordered-list";
    BLOCKS["UL_LIST"] = "unordered-list";
    BLOCKS["LIST_ITEM"] = "list-item";
    BLOCKS["HR"] = "hr";
    BLOCKS["QUOTE"] = "blockquote";
    BLOCKS["EMBEDDED_ENTRY"] = "embedded-entry-block";
    BLOCKS["EMBEDDED_ASSET"] = "embedded-asset-block";
    BLOCKS["TABLE"] = "table";
    BLOCKS["TABLE_ROW"] = "table-row";
    BLOCKS["TABLE_CELL"] = "table-cell";
    BLOCKS["TABLE_HEADER_CELL"] = "table-header-cell";
})(exports.BLOCKS || (exports.BLOCKS = {}));

});

unwrapExports(blocks);
blocks.BLOCKS;

var inlines = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.INLINES = void 0;
(function (INLINES) {
    INLINES["HYPERLINK"] = "hyperlink";
    INLINES["ENTRY_HYPERLINK"] = "entry-hyperlink";
    INLINES["ASSET_HYPERLINK"] = "asset-hyperlink";
    INLINES["EMBEDDED_ENTRY"] = "embedded-entry-inline";
})(exports.INLINES || (exports.INLINES = {}));

});

unwrapExports(inlines);
inlines.INLINES;

var marks = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Map of all Contentful marks.
 */
var MARKS;
(function (MARKS) {
    MARKS["BOLD"] = "bold";
    MARKS["ITALIC"] = "italic";
    MARKS["UNDERLINE"] = "underline";
    MARKS["CODE"] = "code";
})(MARKS || (MARKS = {}));
exports.default = MARKS;

});

unwrapExports(marks);

var schemaConstraints = createCommonjsModule(function (module, exports) {
var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.V1_NODE_TYPES = exports.TEXT_CONTAINERS = exports.HEADINGS = exports.CONTAINERS = exports.VOID_BLOCKS = exports.TABLE_BLOCKS = exports.LIST_ITEM_BLOCKS = exports.TOP_LEVEL_BLOCKS = void 0;


/**
 * Array of all top level block types.
 * Only these block types can be the direct children of the document.
 */
exports.TOP_LEVEL_BLOCKS = [
    blocks.BLOCKS.PARAGRAPH,
    blocks.BLOCKS.HEADING_1,
    blocks.BLOCKS.HEADING_2,
    blocks.BLOCKS.HEADING_3,
    blocks.BLOCKS.HEADING_4,
    blocks.BLOCKS.HEADING_5,
    blocks.BLOCKS.HEADING_6,
    blocks.BLOCKS.OL_LIST,
    blocks.BLOCKS.UL_LIST,
    blocks.BLOCKS.HR,
    blocks.BLOCKS.QUOTE,
    blocks.BLOCKS.EMBEDDED_ENTRY,
    blocks.BLOCKS.EMBEDDED_ASSET,
    blocks.BLOCKS.TABLE,
];
/**
 * Array of all allowed block types inside list items
 */
exports.LIST_ITEM_BLOCKS = [
    blocks.BLOCKS.PARAGRAPH,
    blocks.BLOCKS.HEADING_1,
    blocks.BLOCKS.HEADING_2,
    blocks.BLOCKS.HEADING_3,
    blocks.BLOCKS.HEADING_4,
    blocks.BLOCKS.HEADING_5,
    blocks.BLOCKS.HEADING_6,
    blocks.BLOCKS.OL_LIST,
    blocks.BLOCKS.UL_LIST,
    blocks.BLOCKS.HR,
    blocks.BLOCKS.QUOTE,
    blocks.BLOCKS.EMBEDDED_ENTRY,
    blocks.BLOCKS.EMBEDDED_ASSET,
];
exports.TABLE_BLOCKS = [
    blocks.BLOCKS.TABLE,
    blocks.BLOCKS.TABLE_ROW,
    blocks.BLOCKS.TABLE_CELL,
    blocks.BLOCKS.TABLE_HEADER_CELL,
];
/**
 * Array of all void block types
 */
exports.VOID_BLOCKS = [blocks.BLOCKS.HR, blocks.BLOCKS.EMBEDDED_ENTRY, blocks.BLOCKS.EMBEDDED_ASSET];
/**
 * Dictionary of all container block types, and the set block types they accept as children.
 *
 * Note: This does not include `[BLOCKS.DOCUMENT]: TOP_LEVEL_BLOCKS`
 */
exports.CONTAINERS = (_a = {},
    _a[blocks.BLOCKS.OL_LIST] = [blocks.BLOCKS.LIST_ITEM],
    _a[blocks.BLOCKS.UL_LIST] = [blocks.BLOCKS.LIST_ITEM],
    _a[blocks.BLOCKS.LIST_ITEM] = exports.LIST_ITEM_BLOCKS,
    _a[blocks.BLOCKS.QUOTE] = [blocks.BLOCKS.PARAGRAPH],
    _a[blocks.BLOCKS.TABLE] = [blocks.BLOCKS.TABLE_ROW],
    _a[blocks.BLOCKS.TABLE_ROW] = [blocks.BLOCKS.TABLE_CELL, blocks.BLOCKS.TABLE_HEADER_CELL],
    _a[blocks.BLOCKS.TABLE_CELL] = [blocks.BLOCKS.PARAGRAPH],
    _a[blocks.BLOCKS.TABLE_HEADER_CELL] = [blocks.BLOCKS.PARAGRAPH],
    _a);
/**
 * Array of all heading levels
 */
exports.HEADINGS = [
    blocks.BLOCKS.HEADING_1,
    blocks.BLOCKS.HEADING_2,
    blocks.BLOCKS.HEADING_3,
    blocks.BLOCKS.HEADING_4,
    blocks.BLOCKS.HEADING_5,
    blocks.BLOCKS.HEADING_6,
];
/**
 * Array of all block types that may contain text and inline nodes.
 */
exports.TEXT_CONTAINERS = __spreadArray([blocks.BLOCKS.PARAGRAPH], exports.HEADINGS, true);
/**
 * Node types before `tables` release.
 */
exports.V1_NODE_TYPES = [
    blocks.BLOCKS.DOCUMENT,
    blocks.BLOCKS.PARAGRAPH,
    blocks.BLOCKS.HEADING_1,
    blocks.BLOCKS.HEADING_2,
    blocks.BLOCKS.HEADING_3,
    blocks.BLOCKS.HEADING_4,
    blocks.BLOCKS.HEADING_5,
    blocks.BLOCKS.HEADING_6,
    blocks.BLOCKS.OL_LIST,
    blocks.BLOCKS.UL_LIST,
    blocks.BLOCKS.LIST_ITEM,
    blocks.BLOCKS.HR,
    blocks.BLOCKS.QUOTE,
    blocks.BLOCKS.EMBEDDED_ENTRY,
    blocks.BLOCKS.EMBEDDED_ASSET,
    inlines.INLINES.HYPERLINK,
    inlines.INLINES.ENTRY_HYPERLINK,
    inlines.INLINES.ASSET_HYPERLINK,
    inlines.INLINES.EMBEDDED_ENTRY,
    'text',
];

});

unwrapExports(schemaConstraints);
schemaConstraints.V1_NODE_TYPES;
schemaConstraints.TEXT_CONTAINERS;
schemaConstraints.HEADINGS;
schemaConstraints.CONTAINERS;
schemaConstraints.VOID_BLOCKS;
schemaConstraints.TABLE_BLOCKS;
schemaConstraints.LIST_ITEM_BLOCKS;
schemaConstraints.TOP_LEVEL_BLOCKS;

var types = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

});

unwrapExports(types);

var nodeTypes = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

});

unwrapExports(nodeTypes);

var emptyDocument = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * A rich text document considered to be empty.
 * Any other document structure than this is not considered empty.
 */
var EMPTY_DOCUMENT = {
    nodeType: blocks.BLOCKS.DOCUMENT,
    data: {},
    content: [
        {
            nodeType: blocks.BLOCKS.PARAGRAPH,
            data: {},
            content: [
                {
                    nodeType: 'text',
                    value: '',
                    marks: [],
                    data: {},
                },
            ],
        },
    ],
};
exports.default = EMPTY_DOCUMENT;

});

unwrapExports(emptyDocument);

var helpers = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.isText = exports.isBlock = exports.isInline = void 0;


/**
 * Tiny replacement for Object.values(object).includes(key) to
 * avoid including CoreJS polyfills
 */
function hasValue(obj, value) {
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var key = _a[_i];
        if (value === obj[key]) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if the node is an instance of Inline.
 */
function isInline(node) {
    return hasValue(inlines.INLINES, node.nodeType);
}
exports.isInline = isInline;
/**
 * Checks if the node is an instance of Block.
 */
function isBlock(node) {
    return hasValue(blocks.BLOCKS, node.nodeType);
}
exports.isBlock = isBlock;
/**
 * Checks if the node is an instance of Text.
 */
function isText(node) {
    return node.nodeType === 'text';
}
exports.isText = isText;

});

unwrapExports(helpers);
helpers.isText;
helpers.isBlock;
helpers.isInline;

var dist = createCommonjsModule(function (module, exports) {
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.helpers = exports.EMPTY_DOCUMENT = exports.MARKS = exports.INLINES = exports.BLOCKS = void 0;

Object.defineProperty(exports, "BLOCKS", { enumerable: true, get: function () { return blocks.BLOCKS; } });

Object.defineProperty(exports, "INLINES", { enumerable: true, get: function () { return inlines.INLINES; } });

Object.defineProperty(exports, "MARKS", { enumerable: true, get: function () { return __importDefault(marks).default; } });
__exportStar(schemaConstraints, exports);
__exportStar(types, exports);
__exportStar(nodeTypes, exports);

Object.defineProperty(exports, "EMPTY_DOCUMENT", { enumerable: true, get: function () { return __importDefault(emptyDocument).default; } });
var helpers$1 = __importStar(helpers);
exports.helpers = helpers$1;

});

unwrapExports(dist);
var dist_1 = dist.helpers;
dist.EMPTY_DOCUMENT;
var dist_3 = dist.MARKS;
var dist_4 = dist.INLINES;
var dist_5 = dist.BLOCKS;

const defaultInline = (type, node, key, h) => {
    return h(
        'span',
        {
            key,
            style: {
                margin: "0px 5px",
                padding: "0 .25rem 0 .75rem",
                border: "1px solid #d3dce0",
                fontFamily: "monospace"
            },
        },
        `inline: ${type}, sys.id: ${node.data.target.sys.id}`
    );
};

const defaultMarkRenderers = {
    [dist_3.BOLD]: (children, key, h) => h('strong', { key }, children),
    [dist_3.ITALIC]: (children, key, h) => h('em', { key }, children),
    [dist_3.UNDERLINE]: (children, key, h) => h('u', { key }, children),
    [dist_3.CODE]: (children, key, h) => h('code', { key }, children)
};

const defaultNodeRenderers = {
    [dist_5.PARAGRAPH]: (node, key, h, next) => (
        h('p', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HEADING_1]: (node, key, h, next) => (
        h('h1', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HEADING_2]: (node, key, h, next) => (
        h('h2', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HEADING_3]: (node, key, h, next) => (
        h('h3', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HEADING_4]: (node, key, h, next) => (
        h('h4', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HEADING_5]: (node, key, h, next) => (
        h('h5', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HEADING_6]: (node, key, h, next) => (
        h('h6', { key }, next(node.content, key, h, next))
    ),
    [dist_5.EMBEDDED_ENTRY]: (node, key, h, next) => (
        h('div', { key }, next(node.content, key, h, next))
    ),
    [dist_5.UL_LIST]: (node, key, h, next) => (
        h('ul', { key }, next(node.content, key, h, next))
    ),
    [dist_5.OL_LIST]: (node, key, h, next) => (
        h('ol', { key }, next(node.content, key, h, next))
    ),
    [dist_5.LIST_ITEM]: (node, key, h, next) => (
        h('li', { key }, next(node.content, key, h, next))
    ),
    [dist_5.QUOTE]: (node, key, h, next) => (
        h('blockquote', { key }, next(node.content, key, h, next))
    ),
    [dist_5.TABLE]: (node, key, h, next) => (
        h('table', { key }, next(node.content, key, h, next))
    ),
    [dist_5.TABLE_ROW]: (node, key, h, next) => (
        h('tr', { key }, next(node.content, key, h, next))
    ),
    [dist_5.TABLE_CELL]: (node, key, h, next) => (
        h('td', { key }, next(node.content, key, h, next))
    ),
    [dist_5.TABLE_HEADER_CELL]: (node, key, h, next) => (
        h('th', { key }, next(node.content, key, h, next))
    ),
    [dist_5.HR]: (_node, key, h) => h('hr', { key }, {}),
    [dist_4.ASSET_HYPERLINK]: (node, key, h) =>
        defaultInline(dist_4.ASSET_HYPERLINK, node, key, h),
    [dist_4.ENTRY_HYPERLINK]: (node, key, h) =>
        defaultInline(dist_4.ENTRY_HYPERLINK, node, key, h),
    [dist_4.EMBEDDED_ENTRY]: (node, key, h) =>
        defaultInline(dist_4.EMBEDDED_ENTRY, node, key, h),
    [dist_4.HYPERLINK]: (node, key, h, next) => {
        return h(
            'a',
            {
                key,
                attrs: {
                  href: node.data.uri
                }
            },
            next(node.content, key, h, next)
        )
    },
    text: ({ marks, value }, key, h, markRenderer) => {
        if (!marks.length) {
            return value;
        }

        const marksReversed = [...marks].reverse();
        return marksReversed.reduce((aggregate, mark, i) => (
            markRenderer[mark.type]([aggregate], `${key}-${i}`, h)
        ), value)
    }
};

const renderNodeList = (nodes, key, renderer) => {
    return nodes.map((node, i) => renderNode(node, `${key}-${i}`, renderer));
};

const renderNode = (node, key, renderer) => {
    const nodeRenderer = renderer.node;
    const createElement = renderer.createElement;

    if (dist_1.isText(node)) {
        // We're at final tip of node branch, can render text.
        const markerRender = renderer.mark;
        return nodeRenderer.text(node, key, createElement, markerRender);
    } else {
        const nextNode = nodes => renderNodeList(nodes, key, renderer);
        if (!nodeRenderer) {
            return createElement('div', `${key} ;lost nodeRenderer`);
        }
        if (!node.nodeType || !nodeRenderer[node.nodeType]) {
            // TODO: Figure what to return when passed an unrecognized node.
            return "(Unrecognized node type) " + (node.nodeType || "empty");
        }
        return nodeRenderer[node.nodeType](node, key, createElement, nextNode);
    }
};

var index = {
    functional: true,

    props: ["document", "nodeRenderers", "markRenderers"],

    render(h, ctx) {
        const renderer = {
            node: {
                ...defaultNodeRenderers,
                ...ctx.props.nodeRenderers
            },
            mark: {
                ...defaultMarkRenderers,
                ...ctx.props.markRenderers
            },
            createElement: h
        };

        return renderNodeList(ctx.props.document.content, "RichText-", renderer);
    }
};

export default index;
